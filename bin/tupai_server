#!/usr/bin/env node
var program = require('commander');
var path = require('path');
var baseDir = path.resolve(__dirname, "..");

var fs = require('fs');
var spawn = require('child_process').spawn;
var http = require('http');
var ejs = require('ejs');
var express = require('express');
var httpProxy = require('http-proxy');
var tupai = require(path.join(baseDir, 'scripts', 'nodejs'));

var tupaijsPath = path.join(baseDir, 'bin', 'tupaijs');
var tupaiRootDir = path.join(baseDir);
var URL = require('url');
var app = express();
var mConfig;

var classListHtml;
var tupaiFilesHtml;

var defaultUpstreamServer  = "http://10.0.0.2:8084/";
var proxyURL;

function main() {
    program
            .option('-p, --printLog', 'print log to stdout. default is off')
            .option('-u, --upstream <URL>', 'upstream server URL to proxy requests. e.g. http://10.0.0.2:8084/')
            .parse(process.argv);

    if(!tupai.isTupaiProjectDir()) {
        console.error('current dir is not a tupai project dir.');
        return;
    }
    mConfig = tupai.getConfig();
    console.log('-s ' + program.upstream);
    proxyURL = program.upstream ? program.upstream : defaultUpstreamServer;

    //tupai.rmdirSync('gen');
    //fs.mkdirSync('gen');
    //genConfigs();
    //genTemplates(function() {
        listTupaiClass(function(){
            renderClassListHtml(function() {
                watchFs();
                startHttpServer(program.printLog);
            });
        });
    //});
}

function execute(args, callback) {
    console.log('spawn :' + tupaijsPath + args);
    var cp = spawn(tupaijsPath, args);

    cp.stderr.pipe(process.stderr);
    if(callback) {
        var result='';
        cp.stdout.on('data', function(data) {
            result += data.toString();
        });
        cp.on('close', function(code) {
            callback(result);
        });
    } else {
        if(mConfig.logTupai) {
            cp.stdout.pipe(process.stdout);
        }
    }
    return cp;
}

function genConfigs() {
    console.log('gen configs:');
    tupai.compileConfigSync(mConfig.configs, mConfig.genConfigs, 'Config');
}

function genTemplates(callback) {
    console.log('gen template files:');
    console.log('    ' + mConfig.templates + ' -> ' + mConfig.genTemplates);
    execute(['templates', mConfig.templates, mConfig.genTemplates, '-m', 'no'])
    .on('exit', function() {
        callback();
    });
}

function genTemplate(filePath, packageName, callback) {
    console.log('gen template file:' + filePath);
    execute(['template', filePath, mConfig.genTemplates, packageName, '-m', 'no'])
    .on('exit', function() {
        callback();
    });
}

function listTupaiClass(callback) {
    var packagejsHtml = '<script src="__tupairoot/libs/package.js"></script>';
    var tupaiSrcDir = path.join(baseDir, 'src', 'tupai');
    execute(['list', '--classPath', tupaiSrcDir, '--ignoreNotFound'], function(output) {
        //if (!output) {return;}
        var classes = JSON.parse(output);
        //console.log(classes);
        var scripts = classes.map(function(cls){
            var path = cls.path;
            var filename = path.replace(tupaiSrcDir + "/", "");
            return '<script src="__tupairoot/src/tupai/' + filename + '"></script>';
        });

        tupaiFilesHtml = packagejsHtml + "\n" + scripts.join("\n");

        callback();
    });

}

function listClass(callback) {
    var classPath = mConfig.genConfigs + ';' + mConfig.genTemplates + ';' + mConfig.sources;
    execute(['list', '--classPath', classPath, '--ignoreNotFound'], function(output) {
        var classList;
        try {
            classList = JSON.parse(output);
        } catch(e) {
            console.log("can't parse classlist. ");
            console.log(output);
        }

        if(classList) {
            callback(classList);
        }
    });
}

function startHttpServer(printLog) {
    console.log('startHttpServer:');

    if(printLog) {
        app.use(express.logger());
    }

    var webDir = path.join(baseDir, 'releases', mConfig.web);

    app.use(express.favicon(path.join(baseDir, 'favicon.ico')));
    app.use('/__js', express.static(mConfig.sources));
    app.use('/__js', express.static(mConfig.genTemplates));
    app.use('/__js', express.static(mConfig.genConfigs));

    app.use('/', function(req, res, next) {
        var p = req.path;
        if(p === '/') p = '/index.html';
        if(p.match(/^\/.*\.html$/)) {
            var filePath = path.join(mConfig.web, p);
            if(!fs.existsSync(filePath)) {
                next();
            } else {
                var content = fs.readFileSync(filePath).toString();
                content = content.replace(/<!--[ ]*__js_files__[ ]*-->[\s\S]*<!--[ ]*__js_files__[ ]*-->/, classListHtml);
                content = content.replace(/<!-- *__tupai_files__ *-->[\s\S]*<!-- *__tupai_files__ *-->/, tupaiFilesHtml);
                res.send(content);
            }
        } else if(p == '/js/tupai.min.js') {
            var content = fs.readFileSync(path.join(webDir, 'tupai-last.js')).toString();
            res.send(content);
        } else {
            next();
        }
    });

    app.use('/__tupairoot', express.static(tupaiRootDir));

    app.use('/tupai', express.static(webDir));
    app.use('/tupai', express.directory(webDir));
    app.use('/templates', express.static(mConfig.templates));
    app.use('/templates', express.directory(mConfig.templates));

    var u = URL.parse(proxyURL);
    var proxy = httpProxy.createProxyServer({secure:false});
    console.log('proxy: /  -> ' + proxyURL);
    app.use('/', function(req, res) {
        proxy.web(req, res, {
            target: proxyURL,
        });
    });

    app.use('/', express.static(mConfig.web));
    var port = 30000;
    http.createServer(app).listen(port, function() {
        console.log('\nopen below url in your browser.');
        console.log('http://localhost:' + port);
    });
}


function renderClassListHtml(callback) {
    listClass(function(cl) {
        //classListHtml = '<script src="__js/Config.js"></script>';
        classListHtml = '';
        cl.forEach(function(classzz) {
            classListHtml += '\n<script src="__js/' + classzz.name.split('.').join('/') + '.js"></script>';
        });
        callback && callback();
    });
}

var chokidar = require('chokidar');
function watchFs() {
    console.log('start watching files:');

    var paths = [mConfig.sources, mConfig.templates, mConfig.configs];
    paths.forEach(function(path) {
        console.log('    watching ' + path);
    });

    var renderClassListHtmlFn = function(changeType) {
        // TODO when change js file to add use will not render class list.
        if(changeType !== 'change') {
            renderClassListHtml();
        }
    };
    var rules = [
        {
            regexp: new RegExp(mConfig.sources + "\/.*\.js$"),
            fn: function(changeType, filePath) {
                renderClassListHtmlFn(changeType);
            }
        },
        {
            regexp: new RegExp(mConfig.templates + "\/.*\.html$"),
            fn: function(changeType, filePath) {
                if(changeType === 'unlink') {
                    fs.unlinkSync(path.join('gen', filePath.replace(/\.html$/, '.js')));
                    renderClassListHtmlFn(changeType);
                } else {
                    var classPath = path.relative(mConfig.templates, filePath).replace(/\.html$/, '');
                    genTemplate(filePath, classPath.split('/').join('.'), function() {
                        renderClassListHtmlFn(changeType);
                    });
                }
            }
        },
        {
            regexp: new RegExp(mConfig.configs + "\/.*\.json$"),
            fn: function(changeType, filePath) {
                try {
                    genConfigs();
                } catch(e) {
                    console.error('can\'t generate configs', e);
                }
            }
        }
    ];

    var changeFn = function(changeType, filePath) {
        console.log(changeType + ':' + filePath);
        rules.forEach(function(rule) {
            if(filePath.match(rule.regexp)) {
                rule.fn(changeType, filePath);
            }
        });
    };

    var ignoredFn = function(path, st) {
        if(/\/\./.test(path)) return true;
        if(/\/.*~$/.test(path)) return true;
        return false;
    };
    var watcher = chokidar.watch(paths, {ignored: ignoredFn, persistent: true, ignoreInitial: true});
    ['add', 'change', 'unlink'].forEach(function(changeType) {
        watcher.on(changeType, function(filePath) {
            changeFn(changeType, filePath);
        });
    });
    watcher.on('error', function(error) {
        console.error('Error happened', error);
    });
}

main();
